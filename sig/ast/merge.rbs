module Ast
  module Merge
    VERSION: String

    # Base error class for all merge operations
    class Error < StandardError
    end

    # Raised when parsing fails (template or destination)
    class ParseError < Error
      attr_reader errors: untyped
      attr_reader content: String?

      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Raised when parsing the template (source) content fails
    class TemplateParseError < ParseError
      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Raised when parsing the destination content fails
    class DestinationParseError < ParseError
      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Base class for freeze block nodes in AST merge libraries.
    class FreezeNode
      # Pattern configuration for freeze block markers
      MARKER_PATTERNS: Hash[Symbol, Hash[Symbol, Regexp]]

      # Default pattern when none specified
      DEFAULT_PATTERN: Symbol

      # Error raised when a freeze block has invalid structure
      class InvalidStructureError < StandardError
        attr_reader start_line: Integer?
        attr_reader end_line: Integer?
        attr_reader unclosed_nodes: Array[untyped]

        def initialize: (
          String message,
          ?start_line: Integer?,
          ?end_line: Integer?,
          ?unclosed_nodes: Array[untyped]
        ) -> void
      end

      # Simple location struct for compatibility with AST nodes
      class Location < Struct[Integer]
        attr_accessor start_line: Integer
        attr_accessor end_line: Integer

        def cover?: (Integer line) -> bool
      end

      # Class methods
      def self.register_pattern: (Symbol name, start: Regexp, end_pattern: Regexp) -> Hash[Symbol, Regexp]
      def self.start_pattern: (?Symbol pattern_type) -> Regexp
      def self.end_pattern: (?Symbol pattern_type) -> Regexp
      def self.freeze_start?: (String? line, ?Symbol pattern_type) -> bool
      def self.freeze_end?: (String? line, ?Symbol pattern_type) -> bool
      def self.pattern_types: () -> Array[Symbol]

      # Instance attributes
      attr_reader start_line: Integer
      attr_reader end_line: Integer
      attr_reader content: String?
      attr_reader start_marker: String?
      attr_reader end_marker: String?
      attr_reader pattern_type: Symbol

      def initialize: (
        start_line: Integer,
        end_line: Integer,
        ?start_marker: String?,
        ?end_marker: String?,
        ?pattern_type: Symbol
      ) -> void

      def location: () -> Location
      def slice: () -> String?
      def freeze_node?: () -> bool
      def signature: () -> Array[untyped]
      def inspect: () -> String
      def to_s: () -> String

      private

      def validate_line_order!: () -> void
    end

    # Debug logging module
    module DebugLogger
      def self.env_var_name: () -> String
      def self.env_var_name=: (String name) -> String
      def self.log_prefix: () -> String
      def self.log_prefix=: (String prefix) -> String
      def self.enabled?: () -> bool
      def self.debug: (*untyped args) -> void
      def self.info: (*untyped args) -> void
      def self.warning: (*untyped args) -> void
      def self.time: (String label) { () -> untyped } -> untyped
      def self.log_node: (untyped node, ?label: String) -> void
      def self.extract_lines: (untyped node) -> String
      def self.safe_type_name: (untyped node) -> String
    end

    # Base module for file analysis classes
    module FileAnalysisBase
      # Required instance attributes (must be defined by including class)
      attr_reader statements: Array[untyped]
      attr_reader lines: Array[String]
      attr_reader signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?

      # Get all freeze blocks from statements
      def freeze_blocks: () -> Array[FreezeNode]

      # Check if a line is within a freeze block
      def in_freeze_block?: (Integer line_num) -> bool

      # Get the freeze block containing the given line
      def freeze_block_at: (Integer line_num) -> FreezeNode?

      # Get structural signature for a statement at given index
      def signature_at: (Integer index) -> Array[untyped]?

      # Get a specific line (1-indexed)
      def line_at: (Integer line_num) -> String?

      # Get a normalized line (whitespace-trimmed)
      def normalized_line: (Integer line_num) -> String?

      # Generate signature for a node
      def generate_signature: (untyped node) -> Array[untyped]?

      # Check if a value represents a fallthrough node
      def fallthrough_node?: (untyped value) -> bool

      # Compute default signature for a node (abstract - must be implemented)
      def compute_node_signature: (untyped node) -> Array[untyped]?
    end

    # Base merge result tracking
    class MergeResult
      DECISION_KEPT_TEMPLATE: Symbol
      DECISION_KEPT_DEST: Symbol
      DECISION_MERGED: Symbol
      DECISION_ADDED: Symbol
      DECISION_FREEZE_BLOCK: Symbol
      DECISION_REPLACED: Symbol
      DECISION_APPENDED: Symbol

      attr_reader decisions: Array[Hash[Symbol, untyped]]

      def initialize: () -> void
      def track_decision: (
        untyped node,
        Symbol decision,
        ?reason: String?
      ) -> void
    end

    # Configuration object for SmartMerger options
    class MergerConfig
      VALID_PREFERENCES: Array[Symbol]

      attr_reader signature_match_preference: Symbol | Hash[Symbol, Symbol]
      attr_reader node_splitter: Hash[Symbol, untyped]?
      attr_reader add_template_only_nodes: bool
      attr_reader freeze_token: String?
      attr_reader signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?

      def initialize: (
        ?signature_match_preference: (Symbol | Hash[Symbol, Symbol]),
        ?add_template_only_nodes: bool,
        ?freeze_token: String?,
        ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?,
        ?node_splitter: Hash[Symbol, untyped]?
      ) -> void

      def prefer_destination?: () -> bool
      def prefer_template?: () -> bool
      def to_h: (?default_freeze_token: String?) -> Hash[Symbol, untyped]
      def with: (**untyped options) -> MergerConfig

      def self.destination_wins: (?freeze_token: String?, ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?, ?node_splitter: Hash[Symbol, untyped]?) -> MergerConfig
      def self.template_wins: (?freeze_token: String?, ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?, ?node_splitter: Hash[Symbol, untyped]?) -> MergerConfig

      private

      def validate_preference!: (Symbol preference) -> void
    end
  end
end
