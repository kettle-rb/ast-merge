module Ast
  module Merge
    VERSION: String

    # Base error class for all merge operations
    class Error < StandardError
    end

    # Raised when parsing fails (template or destination)
    class ParseError < Error
      attr_reader errors: untyped
      attr_reader content: String?

      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Raised when parsing the template (source) content fails
    class TemplateParseError < ParseError
      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Raised when parsing the destination content fails
    class DestinationParseError < ParseError
      def initialize: (?String? message, ?errors: untyped, ?content: String?) -> void
    end

    # Base class for freeze block nodes in AST merge libraries.
    class FreezeNode
      # Pattern configuration for freeze block markers
      MARKER_PATTERNS: Hash[Symbol, Hash[Symbol, Regexp]]

      # Default pattern when none specified
      DEFAULT_PATTERN: Symbol

      # Error raised when a freeze block has invalid structure
      class InvalidStructureError < StandardError
        attr_reader start_line: Integer?
        attr_reader end_line: Integer?
        attr_reader unclosed_nodes: Array[untyped]

        def initialize: (
          String message,
          ?start_line: Integer?,
          ?end_line: Integer?,
          ?unclosed_nodes: Array[untyped]
        ) -> void
      end

      # Simple location struct for compatibility with AST nodes
      class Location < Struct[Integer]
        attr_accessor start_line: Integer
        attr_accessor end_line: Integer

        def cover?: (Integer line) -> bool
      end

      # Class methods
      def self.register_pattern: (Symbol name, start: Regexp, end_pattern: Regexp) -> Hash[Symbol, Regexp]
      def self.start_pattern: (?Symbol pattern_type) -> Regexp
      def self.end_pattern: (?Symbol pattern_type) -> Regexp
      def self.freeze_start?: (String? line, ?Symbol pattern_type) -> bool
      def self.freeze_end?: (String? line, ?Symbol pattern_type) -> bool
      def self.pattern_types: () -> Array[Symbol]

      # Instance attributes
      attr_reader start_line: Integer
      attr_reader end_line: Integer
      attr_reader content: String?
      attr_reader start_marker: String?
      attr_reader end_marker: String?
      attr_reader pattern_type: Symbol

      def initialize: (
        start_line: Integer,
        end_line: Integer,
        ?start_marker: String?,
        ?end_marker: String?,
        ?pattern_type: Symbol
      ) -> void

      def location: () -> Location
      def slice: () -> String?
      def freeze_node?: () -> bool
      def signature: () -> Array[untyped]
      def inspect: () -> String
      def to_s: () -> String

      private

      def validate_line_order!: () -> void
    end

    # Debug logging module
    module DebugLogger
      def self.env_var_name: () -> String
      def self.env_var_name=: (String name) -> String
      def self.log_prefix: () -> String
      def self.log_prefix=: (String prefix) -> String
      def self.enabled?: () -> bool
      def self.debug: (*untyped args) -> void
      def self.info: (*untyped args) -> void
      def self.warning: (*untyped args) -> void
      def self.time: (String label) { () -> untyped } -> untyped
      def self.log_node: (untyped node, ?label: String) -> void
      def self.extract_lines: (untyped node) -> String
      def self.safe_type_name: (untyped node) -> String
    end

    # Base module for file analysis classes
    module FileAnalysisBase
      # Required instance attributes (must be defined by including class)
      attr_reader statements: Array[untyped]
      attr_reader lines: Array[String]
      attr_reader signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?

      # Get all freeze blocks from statements
      def freeze_blocks: () -> Array[FreezeNode]

      # Check if a line is within a freeze block
      def in_freeze_block?: (Integer line_num) -> bool

      # Get the freeze block containing the given line
      def freeze_block_at: (Integer line_num) -> FreezeNode?

      # Get structural signature for a statement at given index
      def signature_at: (Integer index) -> Array[untyped]?

      # Get a specific line (1-indexed)
      def line_at: (Integer line_num) -> String?

      # Get a normalized line (whitespace-trimmed)
      def normalized_line: (Integer line_num) -> String?

      # Generate signature for a node
      def generate_signature: (untyped node) -> Array[untyped]?

      # Check if a value represents a fallthrough node
      def fallthrough_node?: (untyped value) -> bool

      # Compute default signature for a node (abstract - must be implemented)
      def compute_node_signature: (untyped node) -> Array[untyped]?
    end

    # Base merge result tracking
    class MergeResult
      DECISION_KEPT_TEMPLATE: Symbol
      DECISION_KEPT_DEST: Symbol
      DECISION_MERGED: Symbol
      DECISION_ADDED: Symbol
      DECISION_FREEZE_BLOCK: Symbol
      DECISION_REPLACED: Symbol
      DECISION_APPENDED: Symbol

      attr_reader decisions: Array[Hash[Symbol, untyped]]

      def initialize: () -> void
      def track_decision: (
        untyped node,
        Symbol decision,
        ?reason: String?
      ) -> void
    end

    # Configuration object for SmartMerger options
    class MergerConfig
      VALID_PREFERENCES: Array[Symbol]

      attr_reader signature_match_preference: Symbol | Hash[Symbol, Symbol]
      attr_reader node_splitter: Hash[Symbol, untyped]?
      attr_reader add_template_only_nodes: bool
      attr_reader freeze_token: String?
      attr_reader signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?

      def initialize: (
        ?signature_match_preference: (Symbol | Hash[Symbol, Symbol]),
        ?add_template_only_nodes: bool,
        ?freeze_token: String?,
        ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?,
        ?node_splitter: Hash[Symbol, untyped]?
      ) -> void

      def prefer_destination?: () -> bool
      def prefer_template?: () -> bool
      def to_h: (?default_freeze_token: String?) -> Hash[Symbol, untyped]
      def with: (**untyped options) -> MergerConfig

      def self.destination_wins: (?freeze_token: String?, ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?, ?node_splitter: Hash[Symbol, untyped]?) -> MergerConfig
      def self.template_wins: (?freeze_token: String?, ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?, ?node_splitter: Hash[Symbol, untyped]?) -> MergerConfig

      private

      def validate_preference!: (Symbol preference) -> void
    end

    # Type alias for node typing callables
    type node_typing_callable = ^(untyped) -> untyped?
    type node_typing_hash = Hash[Symbol | String, node_typing_callable]
    type preference_type = Symbol | Hash[Symbol, Symbol]

    # Abstract base class for SmartMerger implementations
    class SmartMergerBase
      include RegionMergeable

      attr_reader template_content: String
      attr_reader dest_content: String
      attr_reader template_analysis: untyped
      attr_reader dest_analysis: untyped
      attr_reader resolver: untyped
      attr_reader result: untyped
      attr_reader preference: preference_type
      attr_reader add_template_only_nodes: bool
      attr_reader freeze_token: String
      attr_reader signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?
      attr_reader match_refiner: untyped?
      attr_reader node_typing: node_typing_hash?

      def initialize: (
        String template_content,
        String dest_content,
        ?signature_generator: (^(untyped) -> (Array[untyped] | untyped | nil))?,
        ?preference: preference_type,
        ?add_template_only_nodes: bool,
        ?freeze_token: String?,
        ?match_refiner: untyped?,
        ?regions: Array[Hash[Symbol, untyped]]?,
        ?region_placeholder: String?,
        ?node_typing: node_typing_hash?,
        **untyped format_options
      ) -> void

      def merge: () -> String
      def merge_result: () -> untyped

      # Class method for convenient merging
      def self.merge: (
        String template_content,
        String dest_content,
        **untyped options
      ) -> String

      private

      # Abstract methods that subclasses must implement
      def analysis_class: () -> Class
      def perform_merge: () -> untyped

      # Optional hooks for subclasses
      def default_freeze_token: () -> String
      def resolver_class: () -> Class?
      def result_class: () -> Class?
      def aligner_class: () -> Class?
      def build_analysis_options: () -> Hash[Symbol, untyped]
      def build_resolver_options: () -> Hash[Symbol, untyped]
      def build_full_analysis_options: (Symbol source) -> Hash[Symbol, untyped]
      def update_result_content: (untyped result, String content) -> void
      def template_parse_error_class: () -> Class
      def destination_parse_error_class: () -> Class
    end

    # Abstract base class for ConflictResolver implementations
    class ConflictResolverBase
      # Decision constants
      DECISION_KEPT_TEMPLATE: Symbol
      DECISION_KEPT_DEST: Symbol
      DECISION_MERGED: Symbol
      DECISION_ADDED: Symbol
      DECISION_FREEZE_BLOCK: Symbol
      DECISION_APPENDED: Symbol
      DECISION_REPLACED: Symbol

      attr_reader strategy: Symbol
      attr_reader preference: preference_type
      attr_reader template_analysis: untyped
      attr_reader dest_analysis: untyped
      attr_reader add_template_only_nodes: bool
      attr_reader match_refiner: untyped?

      def initialize: (
        strategy: Symbol,
        preference: preference_type,
        template_analysis: untyped,
        dest_analysis: untyped,
        ?add_template_only_nodes: bool,
        ?match_refiner: untyped?,
        **untyped options
      ) -> void

      def resolve: (*untyped args, **untyped kwargs) -> untyped

      # Get preference for a specific node (supports Hash preference)
      def preference_for: (untyped node) -> Symbol

      private

      def validate_preference!: (preference_type preference) -> void
      def resolve_node_pair: (untyped template_node, untyped dest_node, **untyped kwargs) -> untyped
      def resolve_batch: (*untyped args) -> untyped
      def resolve_boundary: (*untyped args) -> untyped
    end

    # Abstract base class for MergeResult implementations
    class MergeResultBase
      # Decision constants
      DECISION_KEPT_TEMPLATE: Symbol
      DECISION_KEPT_DEST: Symbol
      DECISION_MERGED: Symbol
      DECISION_ADDED: Symbol
      DECISION_FREEZE_BLOCK: Symbol
      DECISION_APPENDED: Symbol
      DECISION_REPLACED: Symbol

      attr_reader template_analysis: untyped?
      attr_reader dest_analysis: untyped?
      attr_reader lines: Array[String]
      attr_reader decisions: Array[Hash[Symbol, untyped]]
      attr_reader conflicts: Array[Hash[Symbol, untyped]]
      attr_reader frozen_blocks: Array[untyped]
      attr_reader stats: Hash[Symbol, untyped]

      def initialize: (
        ?template_analysis: untyped?,
        ?dest_analysis: untyped?,
        ?conflicts: Array[Hash[Symbol, untyped]],
        ?frozen_blocks: Array[untyped],
        ?stats: Hash[Symbol, untyped],
        **untyped options
      ) -> void

      def content: () -> Array[String]
      def content?: () -> bool
      def content_string: () -> String
      def to_s: () -> String
      def success?: () -> bool
      def conflicts?: () -> bool
      def track_decision: (Symbol decision, Symbol source, **untyped metadata) -> void
    end

    # Abstract base class for MatchRefiner implementations
    class MatchRefinerBase
      # Default similarity threshold
      DEFAULT_THRESHOLD: Float

      attr_reader threshold: Float
      attr_reader node_types: Array[Symbol]?

      def initialize: (
        ?threshold: Float,
        ?node_types: Array[Symbol]?,
        **untyped options
      ) -> void

      # Find matches between unmatched nodes
      def call: (
        Array[untyped] template_nodes,
        Array[untyped] dest_nodes,
        ?Hash[Symbol, untyped] context
      ) -> Array[MatchResult]

      # Compute similarity score between two nodes
      def similarity: (untyped template_node, untyped dest_node) -> Float

      # Check if a node matches the configured types
      def matches_type?: (untyped node) -> bool

      private

      # Levenshtein distance for string similarity
      def levenshtein_distance: (String s1, String s2) -> Integer
      def string_similarity: (String s1, String s2) -> Float
    end

    # Result of a match refinement operation
    class MatchResult
      attr_reader template_node: untyped
      attr_reader dest_node: untyped
      attr_reader score: Float
      attr_reader metadata: Hash[Symbol, untyped]

      def initialize: (
        template_node: untyped,
        dest_node: untyped,
        score: Float,
        ?metadata: Hash[Symbol, untyped]
      ) -> void

      def to_h: () -> Hash[Symbol, untyped]
    end

    # Module for region-based merging support
    module RegionMergeable
      def regions_configured?: () -> bool
      def setup_regions: (regions: Array[Hash[Symbol, untyped]], region_placeholder: String?) -> void
      def extract_template_regions: (String content) -> String
      def extract_dest_regions: (String content) -> String
      def substitute_merged_regions: (String content) -> String
    end

    # Module for node typing support
    module NodeTyping
      # Wrapper class for typed nodes
      class Wrapper
        attr_reader node: untyped
        attr_reader merge_type: Symbol

        def initialize: (untyped node, Symbol merge_type) -> void
        def method_missing: (Symbol method, *untyped args) ?{ (*untyped) -> untyped } -> untyped
        def respond_to_missing?: (Symbol method, ?bool include_private) -> bool
        def typed_node?: () -> bool
        def unwrap: () -> untyped
        def ==: (untyped other) -> bool
        def hash: () -> Integer
        def eql?: (untyped other) -> bool
        def inspect: () -> String
      end

      def self.with_merge_type: (untyped node, Symbol merge_type) -> Wrapper
      def self.validate!: (node_typing_hash? node_typing) -> void
      def self.apply: (untyped node, node_typing_hash? node_typing) -> untyped
    end
  end
end
