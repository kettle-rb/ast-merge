<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: BACKEND-GRAMMAR-DUPLICATION-ANALYSIS
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "BACKEND-GRAMMAR-DUPLICATION-ANALYSIS";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: BACKEND-GRAMMAR-DUPLICATION-ANALYSIS</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="backend-and-grammar-loading-duplication-analysis">Backend and Grammar Loading Duplication Analysis</h1>

<p><strong>Date:</strong> December 20, 2025  <br>
<strong>Purpose:</strong> Review all vendored *-merge gems for duplicate backend/grammar loading functionality</p>

<h2 id="executive-summary">Executive Summary</h2>

<p>After reviewing all vendored *-merge gems, I found <strong>significant duplication</strong> of backend and grammar loading logic that should be delegated to <code>tree_haver</code>. The gems fall into three categories:</p>

<h3 id="-good---already-using-treehaver-properly">✅ Good - Already Using TreeHaver Properly</h3>
<ul>
  <li>
<strong>prism-merge</strong>: Uses Prism’s native parser, no tree-sitter needed</li>
  <li>
<strong>rbs-merge</strong>: Uses RBS’s native parser, no tree-sitter needed</li>
  <li>
<strong>dotenv-merge</strong>: Uses custom simple parser, no tree-sitter needed</li>
</ul>

<h3 id="️-mixed---using-treehaver-with-legacy-fallback">⚠️ Mixed - Using TreeHaver with Legacy Fallback</h3>
<ul>
  <li>
<strong>bash-merge</strong>: Uses TreeHaver::GrammarFinder but has legacy fallback</li>
  <li>
<strong>json-merge</strong>: Uses TreeHaver but has legacy fallback</li>
  <li>
<strong>jsonc-merge</strong>: Uses TreeHaver::GrammarFinder but has legacy fallback</li>
</ul>

<h3 id="-bad---not-using-treehaver">❌ Bad - NOT Using TreeHaver</h3>
<ul>
  <li>
<strong>toml-merge</strong>: Has completely custom parser path finding (predates TreeHaver integration)</li>
  <li>
<strong>markdown-merge</strong>: Delegates to TreeHaver backends but has custom backend resolution</li>
  <li>
<strong>markly-merge</strong>: Thin wrapper around markdown-merge</li>
  <li>
<strong>commonmarker-merge</strong>: Thin wrapper around markdown-merge</li>
  <li>
<strong>psych-merge</strong>: Uses Psych’s native parser (correct, but could use TreeHaver wrapper)</li>
</ul>

<h2 id="detailed-findings">Detailed Findings</h2>

<h3 id="1-bash-merge-️">1. bash-merge ⚠️</h3>

<p><strong>Location:</strong> <code>vendor/bash-merge/lib/bash/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def self.find_parser_path
  # Use TreeHaver&#39;s GrammarFinder if available
  if defined?(TreeHaver::GrammarFinder)
    TreeHaver::GrammarFinder.new(:bash).find_library_path
  else
    # Fallback: check environment variable first
    env_path = ENV[&quot;TREE_SITTER_BASH_PATH&quot;]
    return env_path if env_path &amp;&amp; File.exist?(env_path)

    # Search common paths
    [
      &quot;/usr/lib/libtree-sitter-bash.so&quot;,
      &quot;/usr/lib64/libtree-sitter-bash.so&quot;,
      &quot;/usr/local/lib/libtree-sitter-bash.so&quot;,
      &quot;/opt/homebrew/lib/libtree-sitter-bash.dylib&quot;,
      &quot;/usr/local/lib/libtree-sitter-bash.dylib&quot;,
    ].find { |path| File.exist?(path) }
  end
end
</code></pre>

<p><strong>Issues:</strong></p>
<ol>
  <li>❌ Has legacy fallback path search duplicating TreeHaver::GrammarFinder</li>
  <li>❌ ENV variable handling duplicates TreeHaver functionality</li>
  <li>✅ At least checks for TreeHaver::GrammarFinder</li>
</ol>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Remove the entire <code>else</code> block</li>
  <li>Make TreeHaver a hard dependency</li>
  <li>Let TreeHaver handle all path finding</li>
</ul>

<hr>

<h3 id="2-json-merge-️">2. json-merge ⚠️</h3>

<p><strong>Location:</strong> <code>vendor/json-merge/lib/json/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def self.find_parser_path
  # Use TreeHaver&#39;s GrammarFinder if available
  if defined?(TreeHaver::GrammarFinder)
    TreeHaver::GrammarFinder.new(:json).find_library_path
  else
    # Fallback: check environment variable first
    env_path = ENV[&quot;TREE_SITTER_JSON_PATH&quot;]
    return env_path if env_path &amp;&amp; File.exist?(env_path)

    # Search common paths
    [
      &quot;/usr/lib/libtree-sitter-json.so&quot;,
      &quot;/usr/lib64/libtree-sitter-json.so&quot;,
      &quot;/usr/local/lib/libtree-sitter-json.so&quot;,
      &quot;/opt/homebrew/lib/libtree-sitter-json.dylib&quot;,
      &quot;/usr/local/lib/libtree-sitter-json.dylib&quot;,
    ].find { |path| File.exist?(path) }
  end
end
</code></pre>

<p><strong>Parse method also has complex logic:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse_json
  unless defined?(TreeHaver)
    error_msg = &quot;TreeHaver not available. Install tree_haver gem.&quot;
    @errors &lt;&lt; error_msg
    @ast = nil
    return
  end

  begin
    # Determine which language to use (do this BEFORE creating parser)
    language = if @parser_path
      # Custom parser path was explicitly provided
      if File.exist?(@parser_path)
        TreeHaver::Language.from_library(@parser_path, symbol: &quot;tree_sitter_json&quot;, name: &quot;json&quot;)
      else
        @errors &lt;&lt; &quot;Provided parser path does not exist: #{@parser_path}&quot;
        @ast = nil
        return
      end
    elsif TreeHaver::Language.respond_to?(:json)
      # Use registered json language (from GrammarFinder)
      TreeHaver::Language.json
    else
      # No language available
      error_msg = if defined?(TreeHaver::GrammarFinder)
        TreeHaver::GrammarFinder.new(:json).not_found_message
      else
        &quot;tree-sitter json parser not found. Install tree-sitter-json or set TREE_SITTER_JSON_PATH.&quot;
      end
      @errors &lt;&lt; error_msg
      @ast = nil
      return
    end
</code></pre>

<p><strong>Issues:</strong></p>
<ol>
  <li>❌ Legacy fallback path search duplicates TreeHaver</li>
  <li>❌ Complex conditional logic for language selection</li>
  <li>❌ Manual error message generation</li>
  <li>✅ Uses TreeHaver when available</li>
</ol>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Simplify to ONLY use TreeHaver</li>
  <li>Remove all fallback logic</li>
  <li>Let TreeHaver::GrammarFinder handle registration and errors</li>
</ul>

<hr>

<h3 id="3-jsonc-merge-️">3. jsonc-merge ⚠️</h3>

<p><strong>Location:</strong> <code>vendor/jsonc-merge/lib/jsonc/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def self.find_parser_path
  # Use TreeHaver&#39;s GrammarFinder if available
  if defined?(TreeHaver::GrammarFinder)
    TreeHaver::GrammarFinder.new(:jsonc).find_library_path
  else
    # Fallback: check environment variable first
    env_path = ENV[&quot;TREE_SITTER_JSONC_PATH&quot;]
    return env_path if env_path &amp;&amp; File.exist?(env_path)

    # Search common paths
    [
      &quot;/usr/lib/libtree-sitter-json.so&quot;,
      &quot;/usr/lib64/libtree-sitter-json.so&quot;,
      &quot;/usr/local/lib/libtree-sitter-json.so&quot;,
      &quot;/opt/homebrew/lib/libtree-sitter-json.dylib&quot;,
      &quot;/usr/local/lib/libtree-sitter-json.dylib&quot;,
    ].find { |path| File.exist?(path) }
  end
end
</code></pre>

<p><strong>Note:</strong> JSONC uses the same tree-sitter-json library, just with different parsing options.</p>

<p><strong>Issues:</strong></p>
<ol>
  <li>❌ Legacy fallback duplicates TreeHaver</li>
  <li>❌ ENV: TREE_SITTER_JSONC_PATH vs tree-sitter-json.so mismatch</li>
  <li>✅ Uses TreeHaver::GrammarFinder when available</li>
</ol>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Remove fallback</li>
  <li>Clarify JSONC uses tree-sitter-json library (not tree-sitter-jsonc)</li>
</ul>

<hr>

<h3 id="4-toml-merge-">4. toml-merge ❌</h3>

<p><strong>Location:</strong> <code>vendor/toml-merge/lib/toml/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Common paths where tree-sitter-toml library might be installed
# Searched in order until one is found
PARSER_SEARCH_PATHS = [
  &quot;/usr/lib/libtree-sitter-toml.so&quot;,
  &quot;/usr/lib64/libtree-sitter-toml.so&quot;,
  &quot;/usr/lib64/libtree-sitter-toml.so.14&quot;,
  &quot;/usr/local/lib/libtree-sitter-toml.so&quot;,
  &quot;/opt/homebrew/lib/libtree-sitter-toml.dylib&quot;,
  &quot;/usr/local/lib/libtree-sitter-toml.dylib&quot;,
].freeze

def self.find_parser_path
  # Check environment variable first
  env_path = ENV[&quot;TREE_SITTER_TOML_PATH&quot;]
  return env_path if env_path &amp;&amp; File.exist?(env_path)

  # Search common paths
  PARSER_SEARCH_PATHS.find { |path| File.exist?(path) }
end
</code></pre>

<p><strong>Parse method:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse_toml
  unless @parser_path &amp;&amp; File.exist?(@parser_path)
    searched = @parser_path || PARSER_SEARCH_PATHS.join(&quot;, &quot;)
    error_msg = &quot;Tree-sitter toml parser not found. Searched: #{searched}. Install tree-sitter-toml or set TREE_SITTER_TOML_PATH.&quot;
    @errors &lt;&lt; error_msg
    @ast = nil
    raise StandardError, error_msg
  end

  begin
    language = TreeSitter::Language.load(&quot;toml&quot;, @parser_path)
    parser = TreeSitter::Parser.new
    parser.language = language
    @ast = parser.parse_string(nil, @source)
</code></pre>

<p><strong>Issues:</strong></p>
<ol>
  <li>❌ <strong>DOES NOT USE TreeHaver at all!</strong>
</li>
  <li>❌ Uses old <code>TreeSitter::Language.load</code> directly (ruby_tree_sitter gem)</li>
  <li>❌ Duplicates all path finding logic</li>
  <li>❌ Hardcoded path list</li>
  <li>❌ Manual ENV variable handling</li>
  <li>❌ Manual error messages</li>
</ol>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>
<strong>Complete rewrite</strong> to use TreeHaver</li>
  <li>This is the worst offender</li>
  <li>Should look like json-merge’s TreeHaver usage</li>
</ul>

<hr>

<h3 id="5-markdown-merge-️">5. markdown-merge ⚠️</h3>

<p><strong>Location:</strong> <code>vendor/markdown-merge/lib/markdown/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def resolve_backend(backend)
  return backend unless backend == Backends::AUTO

  # Try commonmarker first, then markly
  if TreeHaver::Backends::Commonmarker.available?
    :commonmarker
  elsif TreeHaver::Backends::Markly.available?
    :markly
  else
    # Let tree_haver raise the appropriate error
    :commonmarker
  end
end

def create_parser
  case @backend
  when :commonmarker
    create_commonmarker_parser
  when :markly
    create_markly_parser
  else
    raise ArgumentError, &quot;Unknown backend: #{@backend}&quot;
  end
end

def create_commonmarker_parser
  parser = TreeHaver::Backends::Commonmarker::Parser.new
  default_options = {extension: {table: true}}
  options = default_options.merge(@parser_options[:options] || {})
  parser.language = TreeHaver::Backends::Commonmarker::Language.markdown(options: options)
  parser
end

def create_markly_parser
  parser = TreeHaver::Backends::Markly::Parser.new
  flags = @parser_options[:flags]
  extensions = @parser_options[:extensions] || [:table]
  parser.language = TreeHaver::Backends::Markly::Language.markdown(
    flags: flags,
    extensions: extensions,
  )
  parser
end
</code></pre>

<p><strong>Issues:</strong></p>
<ol>
  <li>⚠️ Backend resolution logic could be in TreeHaver</li>
  <li>⚠️ Custom backend availability checking</li>
  <li>✅ Does delegate actual parsing to TreeHaver</li>
  <li>❓ Is this custom logic necessary or could TreeHaver handle it?</li>
</ol>

<p><strong>Assessment:</strong></p>
<ul>
  <li>This is <strong>borderline acceptable</strong> - it’s using TreeHaver but adding its own backend selection logic</li>
  <li>The backend resolution might be specific to markdown-merge’s needs</li>
  <li>
<strong>Question:</strong> Should TreeHaver provide this backend auto-selection?</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li><strong>Evaluate if this logic belongs in TreeHaver</strong></li>
  <li>If yes, move backend auto-selection to TreeHaver</li>
  <li>If no, document why this is markdown-specific</li>
</ul>

<hr>

<h3 id="6-markly-merge--commonmarker-merge-">6. markly-merge &amp; commonmarker-merge ✅</h3>

<p><strong>Location:</strong></p>
<ul>
  <li><code>vendor/markly-merge/lib/markly/merge/file_analysis.rb</code></li>
  <li><code>vendor/commonmarker-merge/lib/commonmarker/merge/file_analysis.rb</code></li>
</ul>

<p><strong>Current Code (markly example):</strong></p>
<pre class="code language-ruby"><code class="language-ruby">class FileAnalysis &lt; Markdown::Merge::FileAnalysis
  DEFAULT_FREEZE_TOKEN = &quot;markly-merge&quot;

  def initialize(source, freeze_token: DEFAULT_FREEZE_TOKEN, signature_generator: nil, flags: ::Markly::DEFAULT, extensions: [:table])
    super(
      source,
      backend: :markly,
      freeze_token: freeze_token,
      signature_generator: signature_generator,
      flags: flags,
      extensions: extensions,
    )
  end
end
</code></pre>

<p><strong>Issues:</strong></p>
<ul>
  <li>✅ <strong>These are thin wrappers - perfect!</strong>
</li>
  <li>✅ Delegate everything to markdown-merge</li>
  <li>✅ Only customize freeze token and backend selection</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Keep as-is</li>
  <li>These are the model for how wrapper gems should work</li>
</ul>

<hr>

<h3 id="7-psych-merge-">7. psych-merge ✅</h3>

<p><strong>Location:</strong> <code>vendor/psych-merge/lib/psych/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse_yaml
  @ast = ::Psych.parse_stream(@source)
rescue ::Psych::SyntaxError =&gt; e
  @errors &lt;&lt; e
  @ast = nil
  # Re-raise to allow SmartMergerBase to wrap with appropriate error type
  raise
end
</code></pre>

<p><strong>Issues:</strong></p>
<ul>
  <li>✅ Uses Psych’s native parser (correct)</li>
  <li>✅ Simple and clean</li>
  <li>❓ Could benefit from TreeHaver’s Psych backend wrapper for consistency</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Consider using <code>TreeHaver::Backends::Psych</code> for consistency</li>
  <li>Not urgent - Psych is native to Ruby</li>
  <li>Low priority</li>
</ul>

<hr>

<h3 id="8-prism-merge-">8. prism-merge ✅</h3>

<p><strong>Location:</strong> <code>vendor/prism-merge/lib/prism/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">@parse_result = DebugLogger.time(&quot;FileAnalysis#parse&quot;) { Prism.parse(source) }

# Use Prism&#39;s native comment attachment
attach_comments_safely!
</code></pre>

<p><strong>Issues:</strong></p>
<ul>
  <li>✅ <strong>Perfect!</strong> Uses Prism’s native parser</li>
  <li>✅ No tree-sitter needed</li>
  <li>✅ Clean and simple</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Keep as-is</li>
  <li>This is the model for native parser gems</li>
</ul>

<hr>

<h3 id="9-rbs-merge-">9. rbs-merge ✅</h3>

<p><strong>Location:</strong> <code>vendor/rbs-merge/lib/rbs/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">@buffer = RBS::Buffer.new(name: &quot;merge.rbs&quot;, content: source)
@buffer, @directives, @declarations = DebugLogger.time(&quot;FileAnalysis#parse&quot;) do
  RBS::Parser.parse_signature(@buffer)
end
</code></pre>

<p><strong>Issues:</strong></p>
<ul>
  <li>✅ <strong>Perfect!</strong> Uses RBS’s native parser</li>
  <li>✅ No tree-sitter needed</li>
  <li>✅ Clean and simple</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Keep as-is</li>
</ul>

<hr>

<h3 id="10-dotenv-merge-">10. dotenv-merge ✅</h3>

<p><strong>Location:</strong> <code>vendor/dotenv-merge/lib/dotenv/merge/file_analysis.rb</code></p>

<p><strong>Current Code:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse_lines(source)
  source.lines.each_with_index.map do |line, index|
    EnvLine.new(line.chomp, index + 1)
  end
end
</code></pre>

<p><strong>Issues:</strong></p>
<ul>
  <li>✅ <strong>Perfect!</strong> Uses simple line-by-line parser</li>
  <li>✅ Dotenv format doesn’t need tree-sitter</li>
  <li>✅ Clean and appropriate</li>
</ul>

<p><strong>Recommendation:</strong></p>
<ul>
  <li>Keep as-is</li>
</ul>

<hr>

<h2 id="comparison-with-treehaver">Comparison with TreeHaver</h2>

<h3 id="treehavers-grammarfinder-reference">TreeHaver’s GrammarFinder (Reference)</h3>

<p><strong>Location:</strong> <code>vendor/tree_haver/lib/tree_haver/grammar_finder.rb</code></p>

<p><strong>Features:</strong></p>
<ol>
  <li>✅ Centralized path search logic</li>
  <li>✅ Security validation (PathValidator)</li>
  <li>✅ Platform-aware (handles .so, .dylib, .dll)</li>
  <li>✅ ENV variable support with validation</li>
  <li>✅ Extra paths support</li>
  <li>✅ Safe mode (trusted directories only)</li>
  <li>✅ Availability checking</li>
  <li>✅ Auto-registration</li>
  <li>✅ Helpful error messages</li>
</ol>

<p><strong>Key Methods:</strong></p>
<ul>
  <li>
<code>find_library_path</code> - Find grammar with ENV override</li>
  <li>
<code>find_library_path_safe</code> - Only trusted directories</li>
  <li>
<code>available?</code> - Check if grammar is available</li>
  <li>
<code>register!</code> - Auto-register with LanguageRegistry</li>
</ul>

<h3 id="treehavers-languageregistry-reference">TreeHaver’s LanguageRegistry (Reference)</h3>

<p><strong>Location:</strong> <code>vendor/tree_haver/lib/tree_haver/language_registry.rb</code></p>

<p><strong>Features:</strong></p>
<ol>
  <li>✅ Thread-safe registration</li>
  <li>✅ Multiple backends per language</li>
  <li>✅ Caching to avoid repeated dlopen</li>
  <li>✅ Backend-specific configuration</li>
</ol>

<hr>

<h2 id="recommendations-summary">Recommendations Summary</h2>

<h3 id="priority-1-critical---remove-duplication">Priority 1: Critical - Remove Duplication</h3>

<ol>
  <li>
<strong>toml-merge</strong> - Complete rewrite to use TreeHaver
    <ul>
      <li>Remove PARSER_SEARCH_PATHS</li>
      <li>Remove custom find_parser_path</li>
      <li>Use TreeHaver::GrammarFinder.new(:toml)</li>
      <li>Use TreeHaver::Parser and TreeHaver::Language</li>
    </ul>
  </li>
  <li>
<strong>bash-merge, json-merge, jsonc-merge</strong> - Remove fallback logic
    <ul>
      <li>Delete the <code>else</code> block in find_parser_path</li>
      <li>Make TreeHaver a hard dependency</li>
      <li>Remove redundant path search code</li>
    </ul>
  </li>
</ol>

<h3 id="priority-2-evaluate-custom-logic">Priority 2: Evaluate Custom Logic</h3>

<ol>
  <li>
<strong>markdown-merge</strong> - Evaluate backend resolution logic
    <ul>
      <li>Determine if backend auto-selection belongs in TreeHaver</li>
      <li>Document decision</li>
      <li>Either move to TreeHaver or document why it’s markdown-specific</li>
    </ul>
  </li>
</ol>

<h3 id="priority-3-optional---consistency">Priority 3: Optional - Consistency</h3>

<ol>
  <li>
<strong>psych-merge</strong> - Consider TreeHaver wrapper
    <ul>
      <li>Use TreeHaver::Backends::Psych for consistency</li>
      <li>Low priority - current implementation is fine</li>
    </ul>
  </li>
</ol>

<hr>

<h2 id="code-smell-checklist">Code Smell Checklist</h2>

<p>Use this checklist when reviewing any *-merge gem’s file_analysis.rb:</p>

<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Has PARSER_SEARCH_PATHS constant</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Has custom find_parser_path method</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Manually checks ENV[“TREE_SITTER_*_PATH”]</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Has hardcoded path list</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Uses <code>TreeSitter::Language.load</code> directly (old API)</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Has <code>defined?(TreeHaver)</code> checks with fallback</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Manually constructs error messages about missing parsers</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>❌ Duplicates path validation logic</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>✅ Uses TreeHaver::GrammarFinder</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>✅ Uses TreeHaver::Parser</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>✅ Uses TreeHaver::Language</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>✅ Delegates backend selection to TreeHaver</li>
</ul>

<hr>

<h2 id="migration-pattern">Migration Pattern</h2>

<h3 id="before-toml-merge-example">Before (toml-merge example):</h3>
<pre class="code language-ruby"><code class="language-ruby">PARSER_SEARCH_PATHS = [
  &quot;/usr/lib/libtree-sitter-toml.so&quot;,
  &quot;/usr/lib64/libtree-sitter-toml.so&quot;,
  # ... more paths
].freeze

def self.find_parser_path
  env_path = ENV[&quot;TREE_SITTER_TOML_PATH&quot;]
  return env_path if env_path &amp;&amp; File.exist?(env_path)
  PARSER_SEARCH_PATHS.find { |path| File.exist?(path) }
end

def parse_toml
  unless @parser_path &amp;&amp; File.exist?(@parser_path)
    error_msg = &quot;Tree-sitter toml parser not found...&quot;
    @errors &lt;&lt; error_msg
    raise StandardError, error_msg
  end
  
  language = TreeSitter::Language.load(&quot;toml&quot;, @parser_path)
  parser = TreeSitter::Parser.new
  parser.language = language
  @ast = parser.parse_string(nil, @source)
end
</code></pre>

<h3 id="after-using-treehaver">After (using TreeHaver):</h3>
<pre class="code language-ruby"><code class="language-ruby">def self.find_parser_path
  TreeHaver::GrammarFinder.new(:toml).find_library_path if defined?(TreeHaver::GrammarFinder)
end

def parse_toml
  unless defined?(TreeHaver)
    error_msg = &quot;TreeHaver not available. Install tree_haver gem.&quot;
    @errors &lt;&lt; error_msg
    @ast = nil
    return
  end

  begin
    # Determine which language to use
    language = if @parser_path &amp;&amp; File.exist?(@parser_path)
      TreeHaver::Language.from_library(@parser_path, symbol: &quot;tree_sitter_toml&quot;, name: &quot;toml&quot;)
    elsif TreeHaver::Language.respond_to?(:toml)
      TreeHaver::Language.toml
    else
      error_msg = if defined?(TreeHaver::GrammarFinder)
        TreeHaver::GrammarFinder.new(:toml).not_found_message
      else
        &quot;tree-sitter toml parser not found. Install tree-sitter-toml or set TREE_SITTER_TOML_PATH.&quot;
      end
      @errors &lt;&lt; error_msg
      @ast = nil
      return
    end

    parser = TreeHaver::Parser.new
    parser.language = language
    @ast = parser.parse(@source)

    if @ast&amp;.root_node&amp;.has_error?
      collect_parse_errors(@ast.root_node)
    end
  rescue StandardError =&gt; e
    @errors &lt;&lt; e
    @ast = nil
  end
end
</code></pre>

<p><strong>Or even simpler</strong>, if we want to remove ALL fallback logic:</p>
<pre class="code language-ruby"><code class="language-ruby">def parse_toml
  raise &quot;TreeHaver not available&quot; unless defined?(TreeHaver)

  language = if @parser_path &amp;&amp; File.exist?(@parser_path)
    TreeHaver::Language.from_library(@parser_path, symbol: &quot;tree_sitter_toml&quot;, name: &quot;toml&quot;)
  else
    TreeHaver::Language.toml # Let TreeHaver handle registration and errors
  end

  parser = TreeHaver::Parser.new
  parser.language = language
  @ast = parser.parse(@source)

  collect_parse_errors(@ast.root_node) if @ast&amp;.root_node&amp;.has_error?
rescue StandardError =&gt; e
  @errors &lt;&lt; e
  @ast = nil
end
</code></pre>

<hr>

<h2 id="next-steps">Next Steps</h2>

<ol>
  <li>
<strong>Review this analysis</strong> with the maintainer</li>
  <li>
<strong>Prioritize</strong> which gems to fix first (suggest: toml-merge)</li>
  <li>
<strong>Create issues</strong> for each gem that needs updating</li>
  <li>
<strong>Document</strong> the standard pattern for future *-merge gems</li>
  <li>
<strong>Consider</strong> adding a linter or test to detect duplication</li>
</ol>

<hr>

<h2 id="questions-for-maintainer">Questions for Maintainer</h2>

<ol>
  <li>Should TreeHaver provide markdown-style backend auto-selection?</li>
  <li>Should all *-merge gems make TreeHaver a hard dependency?</li>
  <li>Is there value in keeping fallback logic for any gem?</li>
  <li>Should we add tests to detect backend/grammar loading duplication?</li>
  <li>Should psych-merge use TreeHaver::Backends::Psych for consistency?</li>
</ol>

<hr>

<h2 id="appendix-file-locations">Appendix: File Locations</h2>

<p>All file_analysis.rb locations for reference:</p>

<ul>
  <li>✅ <code>vendor/bash-merge/lib/bash/merge/file_analysis.rb</code> (297 lines)</li>
  <li>✅ <code>vendor/json-merge/lib/json/merge/file_analysis.rb</code> (238 lines)</li>
  <li>✅ <code>vendor/jsonc-merge/lib/jsonc/merge/file_analysis.rb</code> (341 lines)</li>
  <li>✅ <code>vendor/toml-merge/lib/toml/merge/file_analysis.rb</code> (207 lines)</li>
  <li>✅ <code>vendor/dotenv-merge/lib/dotenv/merge/file_analysis.rb</code> (232 lines)</li>
  <li>✅ <code>vendor/markdown-merge/lib/markdown/merge/file_analysis.rb</code> (345 lines)</li>
  <li>✅ <code>vendor/markly-merge/lib/markly/merge/file_analysis.rb</code> (54 lines)</li>
  <li>✅ <code>vendor/commonmarker-merge/lib/commonmarker/merge/file_analysis.rb</code> (52 lines)</li>
  <li>✅ <code>vendor/prism-merge/lib/prism/merge/file_analysis.rb</code> (563 lines)</li>
  <li>✅ <code>vendor/psych-merge/lib/psych/merge/file_analysis.rb</code> (365 lines)</li>
  <li>✅ <code>vendor/rbs-merge/lib/rbs/merge/file_analysis.rb</code> (265 lines)</li>
</ul>

<p><strong>Total:</strong> 11 file_analysis.rb files reviewed</p>
</div></div>

      <div id="footer">
  Generated on Sun Dec 28 18:06:57 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>