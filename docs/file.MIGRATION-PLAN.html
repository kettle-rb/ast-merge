<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: MIGRATION-PLAN
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "MIGRATION-PLAN";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: MIGRATION-PLAN</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="ast-merge-migration-plan-tree_haver-integration">ast-merge Migration Plan: tree_haver Integration</h1>

<p>This document tracks the migration of all *-merge gems to use tree_haver as the unified AST abstraction layer.</p>

<h2 id="overview">Overview</h2>

<p>The goal is to migrate all *-merge gems to use tree_haver, eliminating per-gem NodeWrapper boilerplate and providing consistent cross-platform backend support.</p>

<h2 id="progress">Progress</h2>

<h3 id="phase-1-tree-sitter-migrations--complete">Phase 1: Tree-sitter Migrations ✅ COMPLETE</h3>

<p>Direct migrations from <code>ruby_tree_sitter</code> to <code>tree_haver</code>:</p>

<table>
  <thead>
    <tr>
      <th>Gem</th>
      <th>Status</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>toml-merge</td>
      <td>✅ Done</td>
      <td>Was the template</td>
    </tr>
    <tr>
      <td>bash-merge</td>
      <td>✅ Done</td>
      <td>Main require, FileAnalysis, NodeWrapper, gemspec</td>
    </tr>
    <tr>
      <td>json-merge</td>
      <td>✅ Done</td>
      <td>Main require, FileAnalysis, NodeWrapper, gemspec</td>
    </tr>
    <tr>
      <td>jsonc-merge</td>
      <td>✅ Done</td>
      <td>Main require, FileAnalysis, NodeWrapper, gemspec</td>
    </tr>
  </tbody>
</table>

<h3 id="phase-2-dotenv-merge--complete">Phase 2: dotenv-merge ✅ COMPLETE</h3>

<table>
  <thead>
    <tr>
      <th>Gem</th>
      <th>Status</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>dotenv-merge</td>
      <td>✅ Done</td>
      <td>Renamed <code>@type</code> → <code>@line_type</code>, added <code>type</code> method for TreeHaver protocol</td>
    </tr>
  </tbody>
</table>

<h3 id="phase-3-psych-backend--psych-merge--complete">Phase 3: Psych Backend &amp; psych-merge ✅ COMPLETE</h3>

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>Status</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Add Psych backend to tree_haver</td>
      <td>✅ Done</td>
      <td>
<code>TreeHaver::Backends::Psych</code> created</td>
    </tr>
    <tr>
      <td>Evaluate psych-merge migration</td>
      <td>✅ Done</td>
      <td><strong>Decision: No migration needed</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Decision Rationale for psych-merge:</strong></p>
<ul>
  <li>Psych is Ruby stdlib (always available, no cross-platform concerns)</li>
  <li>No alternative YAML parsers would benefit from tree_haver abstraction</li>
  <li>psych-merge already has well-architected NodeWrapper with deep Psych integration</li>
  <li>Risk of breaking working code outweighs benefit of consistency</li>
  <li>TreeHaver::Backends::Psych is available for future use if alternative YAML parsers emerge</li>
</ul>

<h3 id="phase-4-markdown-ecosystem--complete">Phase 4: Markdown Ecosystem ✅ COMPLETE</h3>

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>Status</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Add Commonmarker backend</td>
      <td>✅ Done</td>
      <td>
<code>TreeHaver::Backends::Commonmarker</code> created</td>
    </tr>
    <tr>
      <td>Add Markly backend</td>
      <td>✅ Done</td>
      <td>
<code>TreeHaver::Backends::Markly</code> created with type normalization</td>
    </tr>
    <tr>
      <td>Evaluate markdown-merge migration</td>
      <td>✅ Done</td>
      <td><strong>Decision: No migration needed</strong></td>
    </tr>
  </tbody>
</table>

<p><strong>Decision Rationale for markdown ecosystem:</strong></p>
<ul>
  <li>
<code>FileAnalysisBase</code> has deep integration with parser-specific APIs (<code>node.walk</code>, <code>first_child</code>, <code>source_position</code>)</li>
  <li>Both Commonmarker and Markly are already well-abstracted through the base class pattern</li>
  <li>Full migration would require rewriting the base class to use TreeHaver node abstraction</li>
  <li>Risk of breaking working code outweighs benefit of consistency</li>
  <li>TreeHaver backends for Commonmarker/Markly are available for:
    <ul>
      <li>Future tree-sitter-markdown integration</li>
      <li>Other tools that want unified markdown parsing</li>
      <li>Type normalization (Markly’s <code>:header</code> → <code>"heading"</code>, etc.)</li>
    </ul>
  </li>
</ul>

<h3 id="phase-5-rbs-backend-deferred">Phase 5: RBS Backend (Deferred)</h3>

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>Status</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Add RBS backend to tree_haver</td>
      <td>⏳ Deferred</td>
      <td>Lower priority, complex AST</td>
    </tr>
    <tr>
      <td>Migrate rbs-merge</td>
      <td>⏳ Deferred</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="architecture">Architecture</h2>

<pre class="code ruby"><code class="ruby">┌─────────────────────────────────────────────────────────────┐
│                    tree_haver v3.x+                          │
│  Backends: MRI | Rust | FFI | Java | Citrus | Prism | Psych │
│                         │                                    │
│                 TreeHaver::Node protocol                     │
└─────────────────────────────────────────────────────────────┘
                          │
        ┌─────────────────┴─────────────────┐
        │                                   │
        ▼                                   ▼
┌───────────────────┐             ┌─────────────────────────┐
│ Parser-backed     │             │ Synthetic nodes         │
│ TreeHaver::Node   │             │ Ast::Merge::AstNode     │
│ (wraps backends)  │             │ (implements protocol)   │
└───────────────────┘             └─────────────────────────┘
</code></pre>

<h2 id="key-design-principles">Key Design Principles</h2>

<ol>
  <li>
<strong>tree_haver backends are thin wrappers</strong> - They map parser-specific APIs to TreeHaver::Node protocol</li>
  <li>
<strong>*-merge gems focus on merge logic</strong> - No more per-gem NodeWrapper boilerplate</li>
  <li>
<strong>Options passthrough for parsers</strong> - Backends accept parser-specific options via Language class</li>
  <li>
<strong>Type normalization is optional</strong> - Backends can normalize types or pass through</li>
  <li>
<strong>AstNode for synthetic nodes</strong> - Comment nodes, freeze blocks, etc. use AstNode (implements protocol)</li>
</ol>

<h2 id="api-migration-pattern">API Migration Pattern</h2>

<pre class="code language-ruby"><code class="language-ruby"># Old (tree_sitter)
require &quot;tree_sitter&quot;
language = TreeSitter::Language.load(&quot;bash&quot;, path)
parser = TreeSitter::Parser.new
parser.language = language
tree = parser.parse_string(nil, source)
node.start_point.row  # Direct access

# New (tree_haver)
require &quot;tree_haver&quot;
finder = TreeHaver::GrammarFinder.new(:bash)
finder.register! if finder.available?
parser = TreeHaver::Parser.new
parser.language = TreeHaver::Language.bash  # Or from_library()
tree = parser.parse(source)
point = node.start_point
point.respond_to?(:row) ? point.row : point[:row]  # Handles both patterns
</code></pre>

<h2 id="changelog-updates-required">Changelog Updates Required</h2>

<p>When completing each phase, update the unreleased section of:</p>
<ul>
  <li>
<code>vendor/tree_haver/CHANGELOG.md</code> - For new backends</li>
  <li>
<code>vendor/{gem}/CHANGELOG.md</code> - For each migrated gem</li>
  <li>
<code>CHANGELOG.md</code> (ast-merge) - For AstNode/SyntheticNode changes</li>
</ul>
</div></div>

      <div id="footer">
  Generated on Sun Dec 28 16:22:19 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>